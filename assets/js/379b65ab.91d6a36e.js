"use strict";(self.webpackChunkpractica_docs=self.webpackChunkpractica_docs||[]).push([[182],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,g=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?o.createElement(g,i(i({ref:t},c),{},{components:n})):o.createElement(g,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7281:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],s={slug:"pattern-to-reconsider",date:"2022-08-02T10:00",hide_table_of_contents:!0,title:"Popular Node.js tools and patterns that you should re-consider",authors:["goldbergyoni"],tags:["node.js","express","nestjs","fastify","passport","dotenv"]},l="Popular Node.js tools and patterns that you should re-consider",p={permalink:"/blog/pattern-to-reconsider",editUrl:"https://github.com/practicajs/practica/tree/main/docs/blog/pattern-to-reconsider/index.md",source:"@site/blog/pattern-to-reconsider/index.md",title:"Popular Node.js tools and patterns that you should re-consider",description:"Node.js is getting aged, good but also bad (quote from habit). To live longer, Node.js should change its skin, like the phoenix bird and re-consider its patterns",date:"2022-08-02T10:00:00.000Z",formattedDate:"August 2, 2022",tags:[{label:"node.js",permalink:"/blog/tags/node-js"},{label:"express",permalink:"/blog/tags/express"},{label:"nestjs",permalink:"/blog/tags/nestjs"},{label:"fastify",permalink:"/blog/tags/fastify"},{label:"passport",permalink:"/blog/tags/passport"},{label:"dotenv",permalink:"/blog/tags/dotenv"}],readingTime:9.785,truncated:!1,authors:[{name:"Yoni Goldberg",title:"Practica.js core maintainer",url:"https://github.com/goldbergyoni",imageURL:"https://github.com/goldbergyoni.png",key:"goldbergyoni"}],frontMatter:{slug:"pattern-to-reconsider",date:"2022-08-02T10:00",hide_table_of_contents:!0,title:"Popular Node.js tools and patterns that you should re-consider",authors:["goldbergyoni"],tags:["node.js","express","nestjs","fastify","passport","dotenv"]},prevItem:{title:"Which Monorepo is right for a Node.js BACKEND\xa0now?",permalink:"/blog/monorepo-backend"}},c={authorsImageUrls:[void 0]},u=[{value:"1. Dotenv as your configuration source",id:"1-dotenv-as-your-configuration-source",level:2},{value:"2. Calling a &#39;fat&#39; service from the API controller",id:"2-calling-a-fat-service-from-the-api-controller",level:2},{value:"3. Nest.js: Wire <em>everything</em> with dependency injection",id:"3-nestjs-wire-everything-with-dependency-injection",level:2},{value:"4. Passport.js for token authorization",id:"4-passportjs-for-token-authorization",level:2},{value:"5. Supertest for integration/API testing",id:"5-supertest-for-integrationapi-testing",level:2},{value:"6. Fastify decorate for non request/web utilities",id:"6-fastify-decorate-for-non-requestweb-utilities",level:2},{value:"7. Logging from a catch clause",id:"7-logging-from-a-catch-clause",level:2},{value:"8. Package.lock OR Reading environment variables in all the code layers",id:"8-packagelock-or-reading-environment-variables-in-all-the-code-layers",level:2},{value:"9. Use Morgan logger for express web requests",id:"9-use-morgan-logger-for-express-web-requests",level:2},{value:"10. having conditional code based on NODE_ENV value",id:"10-having-conditional-code-based-on-node_env-value",level:2}],d={toc:u};function h(e){var t=e.components,s=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Node.js is getting aged, good but also bad (quote from habit). To live longer, Node.js should change its skin, like the phoenix bird and re-consider its patterns"),(0,r.kt)("p",null,'"Mastery is created by habits. However, sometimes when we\u2019re on auto-pilot performing habits, we tend to slip up... Just being we are gaining experience through performing the habits does not mean that we are improving. We actually go backwards on the improvement scale with most habits that turn into auto-pilot". James suggested that we should alway gauge our habits and occasionally ask - What went well this year?'),(0,r.kt)("p",null,"The difference between a platform that is perceived as obsolete (Ruby?) vs a platform that lives for a long time, is the amount of changes and paradigm changes that the community is willing to consider. Our loyalty is to innovation, an everlast concept unlike Ruby"),(0,r.kt)("p",null,"Am I sure that these patterns are wrong? No, I'm not. The important drill here is keep discussing things and not pasting them because we're used to"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Monorepos",src:n(4).Z,width:"1200",height:"682"})),(0,r.kt)("h2",{id:"1-dotenv-as-your-configuration-source"},"1. Dotenv as your configuration source"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," A super popular technique in which the app configurable values (e.g., DB user name) are stored in a simple text file. Then, when the app loads, the dotenv library sets all the text file values as environment variables so the code can read those"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// .env file\nUSER_SERVICE_URL=https://users.myorg.com\n\n//start.js\nrequire('dotenv').config();\n\n//blog-post-service.js\nrepository.savePost(post);\n//update the user number of posts, read the users service URL from an environment variable\nawait axios.put(`${process.env.USER_SERVICE_URL}/api/user/${post.userId}/incrementPosts`)\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," 21,806,137 downloads/week!"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," Dotenv is so easy and intuitive to start with so one easily overlook fundamental features: It's hard to infer the configuration schema and realize the reason and typing of each key. Consequently, there is no built-in way to fail fast when a mandatory key is missing (a flow might fail after already started and doing side-effects). In the example above, the blog post will be saved to DB and only then too late the code will realize that a mandatory key is missing leaving the app hanging in an invalid state. On top of this, in the precense of many keys, it's not possible to organize them hierarchically. If not enough, it encourages developers to commit this .env file which might contain production values - this happens because there is no clear way to define development defaults (teams usually work around this by committing .env.example file and then asking whomever pulls code to rename this file manually. If they remember of course)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Some configuration libraries provide out of the box solution to all of these needs, mostly a clear schema and the possibility to validate early and fail if needed. See comparison of options here. One of the better alternatives is 'convict', here is the same example, hopefully better:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// config.js\nexport default {\n  userService: {\n    url: {\n        // Hierarchical, documented and strongly typed \ud83d\udc47\n        doc: 'The URL of the user management service including a trailing slash',\n        format: 'url',\n        default: 'http://localhost:4001',\n        nullable: false,\n        env: 'USER_SERVICE_URL',\n        }\n  },\n  //more keys here\n}\n\n//start.js\nimport convict from 'convict';\nimport configSchema from 'config';\nconvict(configSchema);\n// Fail fast!\nconvictConfigurationProvider.validate();\n\n//blog-post.js\nrepository.savePost(post);\n// Will never arrive here if the URL is not set\nawait axios.put(`${convict.get(userService.url)}/api/user/${post.userId}/incrementPosts`)\n")),(0,r.kt)("h2",{id:"2-calling-a-fat-service-from-the-api-controller"},"2. Calling a 'fat' service from the API controller"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," Very often, controllers are thin (great), they delegate the logic to a service. Service is hundred if not thousands line of code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// dirty user service\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," No numbers here but I could confidently say that in ",(0,r.kt)("em",{parentName:"p"},"most")," of the app that I see, this is the case"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," The reader who tries to understand the high-level logic flow, or focus on specific functionality, must mess with huge file/module first"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Use 'Use case', a unique type of object that is responsible to summarize in high-level the flow of each feature/interaction. This way, the reader can understand the major pieces ",(0,r.kt)("em",{parentName:"p"},"easily"),", and can delve into the relevant part without skimming through hundred of lines. Each functionality that the use case invoke, like some calculation, utility, approach to external collaborator is a service. This way, the services are also kept small. code example"),(0,r.kt)("p",null,"Ideas: Encourage breaking down to small services, transactions,     "),(0,r.kt)("h2",{id:"3-nestjs-wire-everything-with-dependency-injection"},"3. Nest.js: Wire ",(0,r.kt)("em",{parentName:"h2"},"everything")," with dependency injection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," You're decorating ",(0,r.kt)("em",{parentName:"p"},"every")," class ",(0,r.kt)("em",{parentName:"p"},"by default")," as injectable. Say A, B, C, although internal details - no unit tests, it's still decorated. DI becomes your coding style, just like you're using classes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"require('dotenv').config();\nconsole.log(process.env.DB_USER_NAME);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," No numbers here but I could confidently say that in ",(0,r.kt)("em",{parentName:"p"},"all")," of the Nest.js app that I see, this is the case"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," DI is not a coding style rather engieering measure that should be used contextually to solve problems. It also has a price that you should consider if worth paying - encapsulation, confusion, slower (Nest.js serverless issue). If you don't need it for a specific class/case, why pay this price? DI is sometimes useful and the right weapon to pull - But it's not always"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Leanify your engineering approach - avoid using any tool unless serves real-world need immediately. Need to dynamically factor some provider? Use if/else with plain simple JS code, need to mock something? monkey patching is also an option (better clutter test code tha production code, right?). Really have a reason to decouple the factoring of a dependency from the dependant? Use DI!"),(0,r.kt)("p",null,"Ideas: The complexity tree, good articles, "),(0,r.kt)("h2",{id:"4-passportjs-for-token-authorization"},"4. Passport.js for token authorization"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," Typical need to validate JWT token, whether you're the issuer or an external issue like Google/Facebook"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"require('dotenv').config();\nconsole.log(process.env.DB_USER_NAME);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," 1,389,720 weekly downloads"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," It brings high abstractions that demand learning new concepts, when basic token authentication demands no more than few lines of code. Passport shines when there is a need to support many providers - int this case the abstraction worth its price"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Code it yourself or with the provider library"),(0,r.kt)("p",null,"Ideas: "),(0,r.kt)("h2",{id:"5-supertest-for-integrationapi-testing"},"5. Supertest for integration/API testing"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," When testing against an API, supertest provides a sweat syntax that can both detect the webserver address, make HTTP call and also assert on the response. A three in one package. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"require('dotenv').config();\nconsole.log(process.env.DB_USER_NAME);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," 2,717,744 weekly downloads"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," You already have your assertion library, why code some tests using another... which actually was suppoed to be HTTP client. On top of this, supertest encourage coupling to express, not API (won't work on remote env, couples to implementation). Last but not least, there are more popular HTTP clients, better maintained and features that might be relevant for testing"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," A popular and standard HTTP client library like Node.js Fetch or Axios"),(0,r.kt)("p",null,"code example"),(0,r.kt)("h2",{id:"6-fastify-decorate-for-non-requestweb-utilities"},"6. Fastify decorate for non request/web utilities"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," Fastify introduces great patterns, preserves the simplicity of express while bringing more batteries. One thing that got me wondering is the 'decorate' feature which allows placing common utilities/services inside a widely accessible container object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"logger example\n")),(0,r.kt)("p",null,"It should be noted that 'decorate' allows scoping the access per plugin/area of the system"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," Fastify has 696,122 weekly download and growing rapidly. The decorator concept is part of the framework's core"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," Some services and utilities serve cross-cutting-concern needs like logger and should be accessible from other layers like domain and DAL. The fastify object is not accessible to this layer, you probably don't want to, req can come from MQ"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," A good old Node.js module is a standard way to expose functionality. It should be noted that Node.js module won't provide scoped access/configuration per specific routes"),(0,r.kt)("p",null,"Code example of logger"),(0,r.kt)("h2",{id:"7-logging-from-a-catch-clause"},"7. Logging from a catch clause"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," You catch an error somewhere deep in the code (not on the route level), then call logger.error to make this error observable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"try{\n    axios.post('https://thatService.io/api/users);\n}\ncatch(error){\n    logger.error(error, this, {operation: addNewOrder});\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," Hard to put my hands on numbers but it's quite popular, right?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," Error should get handled/logged in a central location. Often do I see various catch clauses that handle the error in a different way with different tags for example. This behaviour is also likely to change, consider incrementing a metric on every error, and keeping this DRY is valuable here. Other than that, there should be a motivation to put a catch clause instead of letting the error bubble down to the route/entry-point. It's useful if we wish to change the flow based on the error or enrich the error with more information - this is not the case here"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Avoid catch, let the error bubble down the layer, unless the error changes the flow or there is value in enriching the error with more context. When deciding to use catch, delegate the handling/logging to your centralized handler"),(0,r.kt)("p",null,"Code example of catch and handler"),(0,r.kt)("h2",{id:"8-packagelock-or-reading-environment-variables-in-all-the-code-layers"},"8. Package.lock OR Reading environment variables in all the code layers"),(0,r.kt)("p",null,"The Monorepo market is hot like fire. Weirdly, now when the demand for Monoreps is exploding, one of the leading libraries\u200a-\u200aLerna- has just retired. When looking closely, it might not be just a coincidence\u200a-\u200aWith so many disruptive and shiny features brought on by new vendors, Lerna "),(0,r.kt)("h2",{id:"9-use-morgan-logger-for-express-web-requests"},"9. Use Morgan logger for express web requests"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:")," In many express, found the following line merely logs the request info"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"try{\n    axios.post('https://thatService.io/api/users);\n}\ncatch(error){\n    logger.error(error, this, {operation: addNewOrder});\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:")," 2,901,574 downloads/week"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," You already have your main logger, right? Is it Pino? Winston? something else? great. Why deal with and configure yet another logger? "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:")," Use you main logger in a middleware and log the desired request/response properties"),(0,r.kt)("p",null,"Code example of logging with Pino"),(0,r.kt)("h2",{id:"10-having-conditional-code-based-on-node_env-value"},"10. having conditional code based on NODE_ENV value"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udc81\u200d\u2642\ufe0f What is it about:"),' To differentiate between the dev and prod env, it\'s common to set a environment variable NODE_ENV with "production|test" so various tooling and code can act differently. For example, some templating engines will cache compiled templates only in prod. Other example, different configuration and services something troublesome'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'if(process.env.NODE_ENV === "production"){\n    // This is unlikely to be tested since test runner usually set NODE_ENV=test\n    setLogger({stdout: true, prettyPrint: false});\n    // If this branch exists, why not add more different configurations:\n    collectMetrics();\n}\nelse{\n    setLogger({splunk: true, prettyPrint: true});\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83d\udcca How popular:"),' 5,034,323 code results in GitHub when searching for "NODE_ENV". It doesn\'t seem like a rare pattern'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud83e\udd14 Why it might be wrong:")," Anytime your code checks whether it's production, this branch can't be tested and might fail in production. In this example... Additionally, it opens the door to add more logic and configuration to these branches. Theoretically one can set NODE_ENV = \"production\" in testing but then what's the point in separating?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u2600\ufe0f Better alternative:"),' Conceptually, there is one environment - "production", developers should strive for ',(0,r.kt)("em",{parentName:"p"},"code")," that is identical while the surrounding services like log aggregator, collaborator REST API (things that we anyway don't test) can differ. In the rare cases where the code behaviour must be different, set a flag per functionality and not per environment - this at least discourages setting more functionality in production or testing if/else branch. See example below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'//package.json\n"scripts": {\n    "start": "LOG_PRETTY_PRINT=false index.js",\n    "test": "LOG_PRETTY_PRINT=true jest"\n}\n\n//index.js\nsetLogger({prettyPrint: process.env.LOG_PRETTY_PRINT})\n')))}h.isMDXComponent=!0},4:function(e,t,n){t.Z=n.p+"assets/images/monorepo-theme-1-3eb3a873dcee4ec971a403a153b75aaa.png"}}]);